{
  "component": "Markdown Editor Undo/Redo System",
  "reviewDate": "2025-10-04",
  "filesReviewed": [
    "components/markdown/markdown-editor.tsx",
    "components/markdown/markdown-toolbar-dropdown.tsx",
    "app/note-editor/new.tsx",
    "app/note-editor/[id].tsx"
  ],
  "currentState": {
    "undoSupport": "Platform-native only",
    "platforms": {
      "ios": "Shake gesture or Cmd+Z / Cmd+Shift+Z",
      "web": "Ctrl+Z / Ctrl+Y (browser native TextInput)",
      "android": "Keyboard-dependent, inconsistent or missing"
    },
    "limitations": [
      "No UI buttons for undo/redo",
      "No guaranteed cross-platform support",
      "Android users may have no undo/redo at all",
      "No manual history tracking",
      "No visual indication of undo/redo availability",
      "No keyboard shortcuts shown to users"
    ]
  },
  "criticalIssues": [
    {
      "severity": "high",
      "title": "No Undo/Redo on Android",
      "description": "Android's TextInput does not guarantee undo/redo support. Many keyboards don't provide this functionality, leaving users with no recovery option.",
      "impact": "Users can accidentally delete large amounts of text with no way to recover",
      "userScenario": "User types 500 words → Accidentally selects all → Accidentally pastes/types over → Content lost forever",
      "recommendation": "Implement custom history stack with undo/redo buttons"
    },
    {
      "severity": "medium",
      "title": "Inconsistent Cross-Platform Experience",
      "description": "iOS users get shake-to-undo, web users get Ctrl+Z, Android users get nothing. No unified experience.",
      "impact": "Fragmented UX, platform-dependent workflows, users don't know what to expect",
      "recommendation": "Provide consistent UI buttons and keyboard shortcuts across all platforms"
    },
    {
      "severity": "medium",
      "title": "No Visual Feedback",
      "description": "Users don't know if undo/redo is available or what state they can return to",
      "impact": "Uncertainty about recovery options, missed opportunities to undo",
      "recommendation": "Add disabled states to undo/redo buttons, show history depth indicator"
    }
  ],
  "proposedSolution": {
    "approach": "Custom history stack with UI controls",
    "features": [
      "Manual history tracking of text changes",
      "Undo/Redo buttons in header (disabled when not available)",
      "Keyboard shortcuts (Ctrl+Z / Cmd+Z, Ctrl+Y / Cmd+Shift+Z)",
      "Debounced history snapshots to avoid too many states",
      "Max history limit (e.g., 50 states) to prevent memory issues",
      "Works consistently on iOS, Android, and Web",
      "Visual disabled states when at history boundaries"
    ],
    "architecture": {
      "historyStack": "Array of {content: string, cursor: {start: number, end: number}}",
      "currentIndex": "Pointer to current position in history",
      "debounce": "500ms delay before creating new history entry",
      "maxHistory": "50 states (configurable)",
      "storage": "In-memory only (resets on screen unmount)"
    }
  },
  "criticalImplementationDetails": {
    "issue1_toolbarBypassDebounce": {
      "problem": "Toolbar actions (Bold, Italic, etc.) should create immediate history entries, not wait 500ms",
      "solution": "Add optional skipDebounce parameter to addToHistory()",
      "implementation": {
        "addToHistory": "const addToHistory = useCallback((newContent: string, newSelection: {start: number, end: number}, skipDebounce = false) => { ... }",
        "toolbarUsage": "// In handleInsert and handleInsertText:\naddToHistory(newContent, selectionRef.current, true); // skipDebounce=true"
      },
      "rationale": "Users expect formatting to be undoable as discrete actions, not merged with typing"
    },
    "issue2_flagTimingRaceCondition": {
      "problem": "Using ref + setTimeout for isAddingToHistory creates race conditions and fragile timing dependencies",
      "solution": "Replace ref-based flag with state-based isUndoRedoAction flag",
      "implementation": {
        "state": "const [isUndoRedoAction, setIsUndoRedoAction] = useState(false);",
        "onChange_effect": "useEffect(() => {\n  if (isUndoRedoAction) return; // Skip history during undo/redo\n  // debounced addToHistory...\n}, [value, isUndoRedoAction]);",
        "undo_function": "const handleUndo = () => {\n  setIsUndoRedoAction(true);\n  onChange(prevState.content); // Won't trigger history due to flag\n  setIsUndoRedoAction(false); // Synchronous state update\n};"
      },
      "rationale": "State-based approach is deterministic, no setTimeout race conditions, works with React render cycle"
    },
    "issue3_historyInitialization": {
      "problem": "When editing existing notes, history starts empty instead of with loaded content. Parent component cannot access child's history state.",
      "solution": "Initialize history with value prop inside MarkdownEditor using lazy initializer or mount effect",
      "implementation": {
        "lazyInitializer": "const [history, setHistory] = useState(() => [{content: value || '', selection: {start: 0, end: 0}}]);",
        "mountEffect": "useEffect(() => {\n  if (value && history[0].content === '') {\n    setHistory([{content: value, selection: {start: 0, end: 0}}]);\n  }\n}, []); // Empty deps = run once on mount"
      },
      "rationale": "Lazy initializer is cleaner. Mount effect works if value changes after mount. Both keep history logic encapsulated in child component."
    },
    "issue4_handlerExposurePattern": {
      "problem": "Phase 2 step 1 didn't show HOW to expose handlers from child to parent",
      "solution": "Two patterns: callback props or imperative handle with forwardRef",
      "implementation": {
        "callbackPattern": "// Child exposes via callback\nuseEffect(() => {\n  onUndoRedoChange?.(canUndo, canRedo);\n}, [canUndo, canRedo]);\n\n// Parent receives via prop\n<MarkdownEditor onUndoRedoChange={(u, r) => { setCanUndo(u); setCanRedo(r); }} />",
        "imperativePattern": "// Child exposes via ref\nuseImperativeHandle(ref, () => ({undo: handleUndo, redo: handleRedo, canUndo, canRedo}));\n\n// Parent calls via ref\nconst ref = useRef();\n<MarkdownEditor ref={ref} />\n<Button onPress={() => ref.current?.undo()} />"
      },
      "rationale": "Callback pattern is simpler. Imperative handle gives parent direct control. Choose based on use case."
    },
    "issue5_queueMicrotaskVsSetTimeout": {
      "problem": "setTimeout(..., 0) relies on event loop timing which varies by environment and can race with React renders",
      "solution": "Use queueMicrotask() which executes after current task but before next event loop iteration",
      "implementation": {
        "before": "setTimeout(() => setIsUndoRedoAction(false), 0);",
        "after": "queueMicrotask(() => setIsUndoRedoAction(false));"
      },
      "rationale": "queueMicrotask is deterministic, executes after synchronous code but before rendering, preventing race conditions"
    },
    "issue6_webOnlyKeyboardShortcuts": {
      "problem": "document.addEventListener only exists on web, causes runtime errors on iOS/Android",
      "solution": "Platform check before adding listeners, document that shortcuts are web-only",
      "implementation": {
        "platformCheck": "if (Platform.OS !== 'web') return;",
        "documentation": "Add note to Phase 3: 'Keyboard shortcuts only work on web. Mobile uses UI buttons only.'"
      },
      "rationale": "Mobile soft keyboards don't have Ctrl/Cmd keys. Web gets enhanced UX with shortcuts, mobile gets consistent UI buttons."
    }
  },
  "preImplementationChecklist": {
    "themeVerification": {
      "task": "Verify colors.disabled exists in theme system",
      "location": "constants/theme.ts or hooks/use-theme-colors.ts",
      "action": "Check if disabled color is defined for all themes, add if missing",
      "fallback": "If colors.disabled doesn't exist, use colors.textSecondary with opacity: 0.5"
    },
    "patternChoice": {
      "task": "Handler exposure pattern for Phase 2 Step 1",
      "decision": "USE CALLBACK PATTERN - onUndoRedoChange(canUndo, canRedo) => void",
      "implementation": "Child component uses useEffect to notify parent of state changes via callback prop",
      "reasoning": "Simpler, more React-idiomatic, no forwardRef complexity, sufficient for UI button control"
    }
  },
  "implementationPlan": {
    "phase1": {
      "name": "History Tracking System",
      "tasks": [
        {
          "step": 1,
          "action": "Add history state to markdown-editor.tsx",
          "file": "components/markdown/markdown-editor.tsx",
          "code": "const [history, setHistory] = useState<Array<{content: string, selection: {start: number, end: number}}>>([{content: '', selection: {start: 0, end: 0}}]);\nconst [historyIndex, setHistoryIndex] = useState(0);\nconst [isUndoRedoAction, setIsUndoRedoAction] = useState(false);\nconst historyTimeoutRef = useRef<NodeJS.Timeout | null>(null);"
        },
        {
          "step": 2,
          "action": "Create history snapshot function with skipDebounce option",
          "file": "components/markdown/markdown-editor.tsx",
          "code": "const addToHistory = useCallback((newContent: string, newSelection: {start: number, end: number}, skipDebounce = false) => {\n  if (isUndoRedoAction) return;\n  \n  const doAddHistory = () => {\n    setHistory(prev => {\n      // Remove any future states if we're not at the end\n      const newHistory = prev.slice(0, historyIndex + 1);\n      // Add new state\n      newHistory.push({content: newContent, selection: newSelection});\n      // Limit history to maxHistory entries\n      if (newHistory.length > 50) {\n        newHistory.shift();\n        return newHistory;\n      }\n      return newHistory;\n    });\n    setHistoryIndex(prev => Math.min(prev + 1, 49));\n  };\n  \n  if (skipDebounce) {\n    // Immediate for toolbar actions\n    doAddHistory();\n  } else {\n    // Debounced for typing\n    if (historyTimeoutRef.current) clearTimeout(historyTimeoutRef.current);\n    historyTimeoutRef.current = setTimeout(doAddHistory, 500);\n  }\n}, [historyIndex, isUndoRedoAction]);"
        },
        {
          "step": 3,
          "action": "Track value changes and add to history",
          "file": "components/markdown/markdown-editor.tsx",
          "code": "useEffect(() => {\n  // Don't add to history during undo/redo actions\n  if (isUndoRedoAction) return;\n  \n  // Don't add empty initial state\n  if (value === '' && history.length === 1) return;\n  \n  // Add to history with debounce (500ms)\n  addToHistory(value, selectionRef.current);\n  \n  // Cleanup timeout on unmount\n  return () => {\n    if (historyTimeoutRef.current) {\n      clearTimeout(historyTimeoutRef.current);\n    }\n  };\n}, [value, isUndoRedoAction, addToHistory]);"
        },
        {
          "step": 4,
          "action": "Implement undo function with state-based prevention",
          "file": "components/markdown/markdown-editor.tsx",
          "code": "const handleUndo = useCallback(() => {\n  if (historyIndex === 0 || isUndoRedoAction) return;\n  \n  setIsUndoRedoAction(true);\n  const prevState = history[historyIndex - 1];\n  onChange(prevState.content);\n  selectionRef.current = prevState.selection;\n  restoreFocus();\n  setHistoryIndex(prev => prev - 1);\n  \n  // Reset flag after React finishes rendering (more robust than setTimeout)\n  queueMicrotask(() => setIsUndoRedoAction(false));\n}, [history, historyIndex, onChange, restoreFocus, isUndoRedoAction]);"
        },
        {
          "step": 5,
          "action": "Implement redo function with state-based prevention",
          "file": "components/markdown/markdown-editor.tsx",
          "code": "const handleRedo = useCallback(() => {\n  if (historyIndex >= history.length - 1 || isUndoRedoAction) return;\n  \n  setIsUndoRedoAction(true);\n  const nextState = history[historyIndex + 1];\n  onChange(nextState.content);\n  selectionRef.current = nextState.selection;\n  restoreFocus();\n  setHistoryIndex(prev => prev + 1);\n  \n  // Reset flag after React finishes rendering (more robust than setTimeout)\n  queueMicrotask(() => setIsUndoRedoAction(false));\n}, [history, historyIndex, onChange, restoreFocus, isUndoRedoAction]);"
        },
        {
          "step": 6,
          "action": "Initialize history with initial value prop",
          "file": "components/markdown/markdown-editor.tsx",
          "code": "// Initialize history with value prop on mount\nuseEffect(() => {\n  if (value && history.length === 1 && history[0].content === '') {\n    setHistory([{ content: value, selection: { start: 0, end: 0 } }]);\n  }\n}, []); // Run once on mount only\n\n// Alternative: Initialize in useState directly\nconst [history, setHistory] = useState<Array<{content: string, selection: {start: number, end: number}}>>(() => [\n  {content: value || '', selection: {start: 0, end: 0}}\n]);"
        },
        {
          "step": 7,
          "action": "Define canUndo and canRedo computed values",
          "file": "components/markdown/markdown-editor.tsx",
          "code": "const canUndo = historyIndex > 0;\nconst canRedo = historyIndex < history.length - 1;"
        },
        {
          "step": 8,
          "action": "Update toolbar actions to create immediate history entries",
          "file": "components/markdown/markdown-editor.tsx",
          "code": "const handleInsert = (before: string, after: string) => {\n  // ... existing insertion logic\n  onChange(newContent);\n  selectionRef.current = { start: newCursorPos, end: newCursorPos };\n  \n  // Immediate history entry for toolbar actions (skipDebounce = true)\n  addToHistory(newContent, selectionRef.current, true);\n  restoreFocus();\n};"
        }
      ]
    },
    "phase2": {
      "name": "UI Controls",
      "tasks": [
        {
          "step": 1,
          "action": "Expose undo/redo handlers and state to parent via props",
          "file": "components/markdown/markdown-editor.tsx",
          "code": "interface MarkdownEditorProps {\n  // ... existing props\n  onUndoRedoChange?: (canUndo: boolean, canRedo: boolean) => void;\n}\n\n// Inside component, notify parent of undo/redo availability\nuseEffect(() => {\n  onUndoRedoChange?.(canUndo, canRedo);\n}, [canUndo, canRedo, onUndoRedoChange]);\n\n// Alternative: Use imperative handle with forwardRef\nuseImperativeHandle(ref, () => ({\n  undo: handleUndo,\n  redo: handleRedo,\n  canUndo,\n  canRedo\n}), [handleUndo, handleRedo, canUndo, canRedo]);"
        },
        {
          "step": 2,
          "action": "Add undo/redo buttons to note editor headers",
          "file": "app/note-editor/new.tsx, app/note-editor/[id].tsx",
          "code": "// In parent component:\nconst editorRef = useRef<{undo: () => void, redo: () => void, canUndo: boolean, canRedo: boolean}>(null);\nconst [canUndo, setCanUndo] = useState(false);\nconst [canRedo, setCanRedo] = useState(false);\n\n// Using callback approach:\n<MarkdownEditor\n  onUndoRedoChange={(canUndo, canRedo) => {\n    setCanUndo(canUndo);\n    setCanRedo(canRedo);\n  }}\n/>\n\n// OR using ref approach:\n<MarkdownEditor ref={editorRef} />\n\nheaderRight: () => (\n  <View style={{flexDirection: 'row', gap: 12}}>\n    <TouchableOpacity onPress={() => editorRef.current?.undo()} disabled={!canUndo}>\n      <MaterialIcons name=\"undo\" size={24} color={canUndo ? colors.text : colors.disabled} />\n    </TouchableOpacity>\n    <TouchableOpacity onPress={() => editorRef.current?.redo()} disabled={!canRedo}>\n      <MaterialIcons name=\"redo\" size={24} color={canRedo ? colors.text : colors.disabled} />\n    </TouchableOpacity>\n    {/* existing toolbar/preview buttons */}\n  </View>\n)"
        },
        {
          "step": 3,
          "action": "Style disabled state for undo/redo buttons",
          "implementation": "Use colors.disabled when canUndo/canRedo is false, add opacity: 0.5"
        }
      ]
    },
    "phase3": {
      "name": "Keyboard Shortcuts (Web Only)",
      "note": "Keyboard shortcuts only work on web platform. iOS/Android have native soft keyboards without Ctrl/Cmd key support.",
      "tasks": [
        {
          "step": 1,
          "action": "Add keyboard event listener (web only)",
          "file": "components/markdown/markdown-editor.tsx",
          "code": "useEffect(() => {\n  // Only add keyboard listeners on web platform\n  if (Platform.OS !== 'web') return;\n  \n  const handleKeyDown = (e: KeyboardEvent) => {\n    const isMac = navigator.platform?.toUpperCase().includes('MAC');\n    const ctrlKey = isMac ? e.metaKey : e.ctrlKey;\n    \n    if (ctrlKey && e.key === 'z' && !e.shiftKey) {\n      e.preventDefault();\n      handleUndo();\n    } else if ((ctrlKey && e.key === 'y') || (ctrlKey && e.shiftKey && e.key === 'z')) {\n      e.preventDefault();\n      handleRedo();\n    }\n  };\n  \n  document.addEventListener('keydown', handleKeyDown);\n  return () => document.removeEventListener('keydown', handleKeyDown);\n}, [handleUndo, handleRedo]);"
        },
        {
          "step": 2,
          "action": "Document platform limitations",
          "implementation": "Add comment explaining that mobile platforms rely on UI buttons only, web gets both UI buttons and keyboard shortcuts"
        }
      ]
    },
    "phase4": {
      "name": "Testing & Polish",
      "tasks": [
        {
          "step": 1,
          "action": "Test typing and undo/redo flow",
          "validation": "Type text → wait 500ms → type more → undo → verify previous state"
        },
        {
          "step": 2,
          "action": "Test history branching",
          "validation": "Type A → undo → type B → verify future history discarded"
        },
        {
          "step": 3,
          "action": "Test keyboard shortcuts on all platforms",
          "validation": "Ctrl+Z (Windows/Android), Cmd+Z (iOS/Mac), Ctrl+Y, Cmd+Shift+Z"
        },
        {
          "step": 4,
          "action": "Test max history limit",
          "validation": "Create 60 states → verify oldest states removed, no memory leak"
        },
        {
          "step": 5,
          "action": "Test disabled states",
          "validation": "At start: undo disabled → after typing: both enabled → at end: redo disabled"
        },
        {
          "step": 6,
          "action": "Test cursor position restoration",
          "validation": "Type → move cursor → undo → verify cursor returns to correct position"
        }
      ]
    }
  },
  "technicalConsiderations": {
    "debouncing": "500ms prevents creating a state for every keystroke, reduces history size",
    "memoryManagement": "50 state limit prevents unbounded growth, oldest states removed first",
    "cursorTracking": "Each history entry includes cursor position for accurate restoration",
    "branching": "Redo history is discarded when new content is added from middle of history",
    "autoSave": "History tracking should not interfere with existing auto-save mechanism",
    "toolbarActions": "Bold, Italic, etc. create immediate history entries via skipDebounce=true parameter",
    "stateFlagApproach": "isUndoRedoAction state prevents infinite loops when undo/redo triggers onChange",
    "historyInitialization": "Initialize history with initial value prop using lazy useState initializer or useEffect on mount",
    "raceConditionPrevention": "queueMicrotask() ensures flag resets after React render cycle, more deterministic than setTimeout(0)",
    "handlerExposure": "Two patterns: callback-based (onUndoRedoChange) or imperative handle (useImperativeHandle + forwardRef)",
    "keyboardShortcuts": "Web only - document.addEventListener only available on web platform, mobile relies on UI buttons",
    "platformDetection": "Use Platform.OS !== 'web' check before adding keyboard listeners to prevent runtime errors"
  },
  "edgeCases": {
    "rapidTyping": "Debounce ensures smooth typing without creating excessive states",
    "paste": "Large paste operations should create single history entry",
    "formatting": "Toolbar formatting actions should bypass debounce and create immediate entries",
    "mounted": "History resets when component unmounts (intentional - avoid stale state)",
    "multipleEditors": "Each note editor instance has independent history"
  },
  "futureEnhancements": {
    "lowPriority": [
      {
        "feature": "Persist history to AsyncStorage",
        "reason": "Survive app restarts, more forgiving UX",
        "complexity": "Medium - requires serialization and storage key management"
      },
      {
        "feature": "History timeline UI",
        "reason": "Visual representation of edit history like Git graph",
        "complexity": "High - requires new UI component and visualization"
      },
      {
        "feature": "Named snapshots",
        "reason": "Allow users to manually mark important states",
        "complexity": "Medium - extends history system with metadata"
      },
      {
        "feature": "Collaborative undo",
        "reason": "Support multi-user editing with conflict resolution",
        "complexity": "Very High - requires real-time sync and CRDT"
      }
    ]
  },
  "uiMockup": {
    "headerLayout": "[ ← ] New Note [ ↶ ] [ ↷ ] [ 🔤 ] [ Preview ]",
    "disabledState": "Gray out ↶ when at history start, gray out ↷ when at history end",
    "buttonOrder": "Back arrow → Undo → Redo → Toolbar → Preview/Edit toggle"
  },
  "accessibilityConsiderations": [
    "Add accessibilityLabel='Undo' and 'Redo' to buttons",
    "Add accessibilityHint='Undo last change' and 'Redo last undone change'",
    "Ensure disabled state is announced by screen readers",
    "Keyboard shortcuts should work with screen reader navigation"
  ],
  "expectedOutcome": {
    "before": {
      "ios": "Shake to undo (hidden, many users don't know)",
      "web": "Ctrl+Z (browser native, works but inconsistent with app)",
      "android": "No undo/redo (data loss risk)"
    },
    "after": {
      "all": "Visible undo/redo buttons in header, keyboard shortcuts, consistent behavior",
      "benefits": [
        "Cross-platform consistency",
        "Discoverability (visible buttons)",
        "Safety net for accidental edits",
        "Professional text editor experience",
        "Reduced user anxiety about data loss"
      ]
    }
  }
}
